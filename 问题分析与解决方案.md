# 课程数据结构问题分析与解决方案

## 问题分析

您发现的"每个教学楼里都只有其他楼层这一个选项"的问题，主要原因在于：

### 1. 原有数据结构的局限性

**原有结构：**
```typescript
interface BuildingInfo {
    building: string;
    label: string;
    value: number;
    infos: CourseInfo[];  // 所有课程都放在一个数组中
}
```

**问题：**
- 课程数据是扁平化的，没有楼层概念
- 前端需要通过解析房间号来推断楼层信息
- 楼层提取逻辑不够灵活，容易出错

### 2. 楼层推断逻辑的问题

**原有推断逻辑：**
```javascript
const floorMatch = room.match(/([A-Z])(\d)/);
const floorName = floorMatch ? `${floorMatch[1]}楼 ${floorMatch[2]}层` : '其他楼层';
```

**存在的问题：**
- 假设房间号格式为 "A101"、"B205" 等
- 如果房间号格式不符合预期，就会归类到"其他楼层"
- 无法处理特殊房间号格式（如 "实验室1"、"多媒体教室A"）

## 解决方案

### 1. 新的API数据结构

**四级层次结构：**
```
学部 (Division) 
  ├── 教学楼 (Building)
      ├── 楼层 (Floor)
          ├── 教室 (Room)
          └── 课程 (Course)
```

**核心优势：**
- 🏗️ **层次明确**：楼层信息由后端直接提供，不需要前端推断
- 📊 **数据完整**：每个层级都包含完整的元信息
- 🔍 **查询高效**：支持按层级精确筛选
- 🚀 **易于扩展**：可以轻松添加新的层级或字段

### 2. 新的数据结构设计

```typescript
// 学部信息
interface DivisionInfo {
  divisionId: string;        // "liberal_arts", "engineering"
  divisionName: string;      // "文理学部", "工学部"
  buildings: BuildingInfo[];
  totalBuildings: number;
  totalCourses: number;
}

// 教学楼信息  
interface BuildingInfo {
  buildingId: string;        // "building_a", "building_b"
  buildingName: string;      // "文理学部教学楼A"
  buildingCode: string;      // "A", "B", "C"
  floors: FloorInfo[];
  totalFloors: number;
  totalCourses: number;
}

// 楼层信息（关键改进）
interface FloorInfo {
  floorId: string;          // "A_1", "A_2", "B_1"
  floorName: string;        // "A楼1层", "A楼2层"
  floorNumber: number;      // 1, 2, 3
  rooms: RoomInfo[];        // 该楼层的教室列表
  courses: CourseInfo[];    // 该楼层的课程列表
}

// 课程信息（增强版）
interface CourseInfo {
  id: number;
  courseName: string;
  courseCode: string;       // 课程代码
  teacherName: string;
  teacherTitle: string;
  faculty: string;
  room: string;
  timeSlots: TimeSlot[];    // 支持多个时间段
  capacity?: number;
  enrolled?: number;
  averageRating?: number;
  reviewCount?: number;
}
```

### 3. API接口设计

**主要接口：**
```
GET /api/courses                    # 获取完整的四级数据结构
GET /api/courses/search            # 支持多维度筛选
GET /api/courses/{id}/detail       # 获取课程详情
```

**响应示例：**
```json
{
  "code": 0,
  "data": [
    {
      "divisionId": "liberal_arts",
      "divisionName": "文理学部", 
      "buildings": [
        {
          "buildingId": "building_a",
          "buildingName": "文理学部教学楼A",
          "floors": [
            {
              "floorId": "A_1",
              "floorName": "A楼1层",
              "floorNumber": 1,
              "courses": [
                {
                  "id": 1,
                  "courseName": "高等数学A(1)",
                  "room": "A101",
                  "timeSlots": [
                    {
                      "dayOfWeek": 1,
                      "startPeriod": 1,
                      "endPeriod": 2
                    }
                  ]
                }
              ]
            },
            {
              "floorId": "A_2", 
              "floorName": "A楼2层",
              "floorNumber": 2,
              "courses": [...]
            }
          ]
        }
      ]
    }
  ]
}
```

## 实施步骤

### 后端改造

1. **数据库结构调整**
   ```sql
   -- 新增楼层表
   CREATE TABLE floors (
     id VARCHAR(50) PRIMARY KEY,
     building_id VARCHAR(50),
     name VARCHAR(100),
     floor_number INT,
     FOREIGN KEY (building_id) REFERENCES buildings(id)
   );
   
   -- 教室表关联楼层
   ALTER TABLE rooms ADD COLUMN floor_id VARCHAR(50);
   
   -- 课程表通过教室关联楼层
   ```

2. **API接口实现**
   - 实现四级数据聚合逻辑
   - 添加缓存机制提高性能
   - 支持多维度筛选参数

3. **数据迁移**
   - 将现有课程数据按楼层重新组织
   - 确保房间号与楼层的正确映射

### 前端适配

1. **类型定义更新**
   - 使用新的数据结构类型
   - 保持向后兼容性

2. **组件逻辑调整** 
   - 直接使用API提供的楼层数据
   - 移除房间号解析逻辑
   - 优化数据绑定和渲染

3. **用户体验优化**
   - 更准确的楼层导航
   - 更丰富的统计信息展示
   - 更快的数据加载速度

## 预期效果

✅ **解决当前问题**
- 消除"其他楼层"问题
- 楼层分类准确无误  
- 支持复杂房间号格式

✅ **提升用户体验**
- 四级导航更符合直觉
- 楼层信息丰富完整
- 加载速度更快

✅ **增强系统能力**
- 支持更多筛选维度
- 便于数据分析统计
- 易于功能扩展

## 兼容性说明

为了确保平滑升级，我们提供了：

1. **数据转换适配器**：将新数据结构转换为旧格式
2. **渐进式迁移**：可以先在新接口中使用新结构，旧接口保持兼容
3. **Mock数据支持**：提供完整的测试数据用于开发验证

这样的设计既解决了当前的楼层分类问题，又为未来的功能扩展打下了良好的基础。